{"ast":null,"code":"/*\n * COMB\n * http://www.aliasworkbench.com/theoryBuilders/TB5_evaluate1.htm\n *\n * 1. Curvature (height) = 1 / radius (a proportional value)\n * 2. radius = intersection of 2 tangent lines\n * 3. tangent line = tangent of a point on the spline curve.\n * 4. point on spline curve = calculated or knot value.\n */\nimport Point from './Point';\nimport Line from './Line';\n\nclass COMB {\n  constructor(knots) {\n    this._knots = knots;\n  }\n\n  getNormalByIndex(index) {\n    if (typeof this._normals === \"undefined\" || null === this._normals || index < 0 || index > this._normals.length) return null;\n    return this._normals[index];\n  }\n\n  calculateOrthogonals() {\n    if (typeof this._knots === \"undefined\" || null === this._knots || 0 === this._knots.length) return false;\n    this._normals = [];\n    var line = null;\n    var end = this._knots.length - 1;\n\n    for (var i = 0; i <= end; i++) {\n      var normal = null;\n\n      switch (i) {\n        case 0:\n          line = new Line(this._knots[0], this._knots[1]);\n          normal = this.findNormalOnLine(line, line.pointStart);\n          break;\n\n        case end:\n          line = new Line(this._knots[end - 1], this._knots[end]);\n          normal = this.findNormalOnLine(line, line.pointStart);\n          break;\n\n        default:\n          normal = this.findNormalProjection(this._knots[i - 1], this._knots[i], this._knots[i + 1]);\n          break;\n      } // orthogonal normal line\n\n\n      this._normals.push(normal);\n    }\n  }\n  /*\n   * find normal line on spline line directly (start, end)\n   */\n\n\n  findNormalOnLine(line, // line to be normal from \n  point) // point on line to extend normal\n  {}\n  /*\n   * find normal line by projection (between start, end)\n   */\n\n\n  findNormalProjection(p0, // left\n  p, // projection point\n  p1) // right\n  {\n    // find line representing knot\n    var dis = p.distanceFromPoint(p0);\n    var line = new Line(p, p1);\n    var pp = line.findPointOnLineBetweenPoints(dis); // find normal of line -- projection\n\n    line = new Line(p0, pp);\n    var normal = line.findTangentThroughPoint(p); // find appropriate start 'p' + end point p -> distance 1/radius\n  }\n  /*\n   * 1. Curvature (height) = 1 / radius (a proportional value)\n   * 2. radius = intersection of 2 tangent lines\n   */\n\n\n  findRadius() {}\n\n}\n\nexport default COMB;","map":{"version":3,"sources":["/home/parvin/Documents/my-app/src/COMB.js"],"names":["Point","Line","COMB","constructor","knots","_knots","getNormalByIndex","index","_normals","length","calculateOrthogonals","line","end","i","normal","findNormalOnLine","pointStart","findNormalProjection","push","point","p0","p","p1","dis","distanceFromPoint","pp","findPointOnLineBetweenPoints","findTangentThroughPoint","findRadius"],"mappings":"AAAA;;;;;;;;;AAUA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,IAAP,MAAiB,QAAjB;;AAEC,MAAMC,IAAN,CACA;AACGC,EAAAA,WAAW,CAACC,KAAD,EACX;AACI,SAAKC,MAAL,GAAcD,KAAd;AACH;;AAEDE,EAAAA,gBAAgB,CAACC,KAAD,EAChB;AACI,QAAG,OAAO,KAAKC,QAAZ,KAAwB,WAAxB,IACC,SAAS,KAAKA,QADf,IAECD,KAAK,GAAG,CAFT,IAEcA,KAAK,GAAG,KAAKC,QAAL,CAAcC,MAFvC,EAGI,OAAO,IAAP;AAEJ,WAAO,KAAKD,QAAL,CAAcD,KAAd,CAAP;AACH;;AAEDG,EAAAA,oBAAoB,GACpB;AACI,QAAI,OAAO,KAAKL,MAAZ,KAAsB,WAAtB,IACA,SAAQ,KAAKA,MADb,IAEA,MAAI,KAAKA,MAAL,CAAYI,MAFpB,EAGI,OAAO,KAAP;AAEJ,SAAKD,QAAL,GAAgB,EAAhB;AACA,QAAIG,IAAI,GAAG,IAAX;AACA,QAAIC,GAAG,GAAG,KAAKP,MAAL,CAAYI,MAAZ,GAAmB,CAA7B;;AACA,SAAI,IAAII,CAAC,GAAC,CAAV,EAAaA,CAAC,IAAGD,GAAjB,EAAsBC,CAAC,EAAvB,EACA;AACI,UAAIC,MAAM,GAAG,IAAb;;AACA,cAAOD,CAAP;AAEI,aAAK,CAAL;AACAF,UAAAA,IAAI,GAAG,IAAIV,IAAJ,CAAS,KAAKI,MAAL,CAAY,CAAZ,CAAT,EAAyB,KAAKA,MAAL,CAAY,CAAZ,CAAzB,CAAP;AACAS,UAAAA,MAAM,GAAG,KAAKC,gBAAL,CAAsBJ,IAAtB,EAA4BA,IAAI,CAACK,UAAjC,CAAT;AACA;;AAEA,aAAKJ,GAAL;AACAD,UAAAA,IAAI,GAAG,IAAIV,IAAJ,CAAS,KAAKI,MAAL,CAAYO,GAAG,GAAC,CAAhB,CAAT,EAA6B,KAAKP,MAAL,CAAYO,GAAZ,CAA7B,CAAP;AACAE,UAAAA,MAAM,GAAG,KAAKC,gBAAL,CAAsBJ,IAAtB,EAA4BA,IAAI,CAACK,UAAjC,CAAT;AACA;;AAEA;AACAF,UAAAA,MAAM,GAAG,KAAKG,oBAAL,CAA0B,KAAKZ,MAAL,CAAYQ,CAAC,GAAC,CAAd,CAA1B,EAA4C,KAAKR,MAAL,CAAYQ,CAAZ,CAA5C,EAA4D,KAAKR,MAAL,CAAYQ,CAAC,GAAC,CAAd,CAA5D,CAAT;AACA;AAdJ,OAFJ,CAmBI;;;AACA,WAAKL,QAAL,CAAcU,IAAd,CAAmBJ,MAAnB;AACH;AACJ;AAED;;;;;AAGAC,EAAAA,gBAAgB,CAACJ,IAAD,EAAU;AACVQ,EAAAA,KADA,EACU;AAC1B,GAEC;AAED;;;;;AAGAF,EAAAA,oBAAoB,CAACG,EAAD,EAAQ;AACPC,EAAAA,CADD,EACQ;AACPC,EAAAA,EAFD,EAEQ;AAC5B;AACI;AACA,QAAIC,GAAG,GAAGF,CAAC,CAACG,iBAAF,CAAoBJ,EAApB,CAAV;AACA,QAAIT,IAAI,GAAG,IAAIV,IAAJ,CAASoB,CAAT,EAAYC,EAAZ,CAAX;AACA,QAAIG,EAAE,GAAGd,IAAI,CAACe,4BAAL,CAAkCH,GAAlC,CAAT,CAJJ,CAMI;;AACAZ,IAAAA,IAAI,GAAG,IAAIV,IAAJ,CAASmB,EAAT,EAAaK,EAAb,CAAP;AACA,QAAIX,MAAM,GAAGH,IAAI,CAACgB,uBAAL,CAA6BN,CAA7B,CAAb,CARJ,CAUI;AACH;AAED;;;;;;AAIAO,EAAAA,UAAU,GACV,CAEC;;AAtFJ;;AAyFA,eAAe1B,IAAf","sourcesContent":["/*\n * COMB\n * http://www.aliasworkbench.com/theoryBuilders/TB5_evaluate1.htm\n *\n * 1. Curvature (height) = 1 / radius (a proportional value)\n * 2. radius = intersection of 2 tangent lines\n * 3. tangent line = tangent of a point on the spline curve.\n * 4. point on spline curve = calculated or knot value.\n */\n\nimport Point from './Point';\nimport Line from './Line';\n\n class COMB\n {\n    constructor(knots)\n    {\n        this._knots = knots;\n    }\n\n    getNormalByIndex(index)\n    {\n        if(typeof(this._normals)===\"undefined\" ||\n            null === this._normals ||\n            index < 0 || index > this._normals.length)\n            return null;\n\n        return this._normals[index];\n    }\n\n    calculateOrthogonals()\n    {\n        if (typeof(this._knots)===\"undefined\" ||\n            null ===this._knots ||\n            0===this._knots.length)\n            return false;\n\n        this._normals = [];\n        var line = null;\n        var end = this._knots.length-1;\n        for(var i=0; i<= end; i++)\n        {\n            var normal = null;\n            switch(i)\n            {\n                case 0:\n                line = new Line(this._knots[0], this._knots[1])\n                normal = this.findNormalOnLine(line, line.pointStart);\n                break;\n\n                case end:\n                line = new Line(this._knots[end-1], this._knots[end])\n                normal = this.findNormalOnLine(line, line.pointStart);\n                break;\n\n                default:\n                normal = this.findNormalProjection(this._knots[i-1], this._knots[i], this._knots[i+1]);\n                break;\n            }\n\n            // orthogonal normal line\n            this._normals.push(normal);\n        }\n    }\n\n    /*\n     * find normal line on spline line directly (start, end)\n     */\n    findNormalOnLine(line,    // line to be normal from \n                    point)    // point on line to extend normal\n    {\n        \n    }\n\n    /*\n     * find normal line by projection (between start, end)\n     */\n    findNormalProjection(p0,    // left\n                         p,     // projection point\n                         p1)    // right\n    {\n        // find line representing knot\n        var dis = p.distanceFromPoint(p0);\n        var line = new Line(p, p1);\n        var pp = line.findPointOnLineBetweenPoints(dis);\n        \n        // find normal of line -- projection\n        line = new Line(p0, pp);\n        var normal = line.findTangentThroughPoint(p);\n\n        // find appropriate start 'p' + end point p -> distance 1/radius\n    }\n\n    /*\n     * 1. Curvature (height) = 1 / radius (a proportional value)\n     * 2. radius = intersection of 2 tangent lines\n     */\n    findRadius()\n    {\n\n    }\n }\n\n export default COMB;"]},"metadata":{},"sourceType":"module"}