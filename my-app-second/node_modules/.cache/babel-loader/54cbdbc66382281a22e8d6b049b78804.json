{"ast":null,"code":"// ============================================================================\n// Module:\t\tCubicSpline.js\n//\n// Description:\t2D Cubic Spline interpolation in javascript as defined by reference.\n//\t\t\t\t\n// Reference:\tNumerical Recipes in C 2nd Edition, Press, Teukolsky, Vetterling, Flannery, pg.113\n//\t\t\t\n// Authors:\t\tWilliam H. Press\n//\t\t\t\tWilliam T. Vetterling\n//\t\t\t\tSaul A. Teukolsky\n//\t\t\t\tBrian P. Flannery\n//\n//\t\t\t\tC.T. Yeung (porting from C into javascript)\n//\n// Input:\t\tpSrcX - array of anchors' x (assume positive real numbers)\n//\t\t\t\tpSrcY - array of anchors' y (assume positive real numbers)\n//\n// Output:\t\tgetY(x) => returns interpolated Y value.\n//\n// WARNING:     must invoke formulate() after all knots are added before getY(x)\n//\n// History:\t\n// 20Nov11\t\tported it to javascript, working in HTML5 canvas.\t\t\tcty\n// 12Nov17      upgrade to ECMAScript6                                      cty\n// ============================================================================\nimport Point from './Point';\n\nclass CubicSpline {\n  constructor() {\n    this.init();\n  }\n  /*\n   * instantiate all arrays (knots + intermediate)\n   */\n\n\n  init() {\n    this.arySrcX = [];\n    this.arySrcY = [];\n    this.initIntermediate();\n  }\n  /*\n   * instantiate intermediate arrays\n   */\n\n\n  initIntermediate() {\n    this.aryB = [];\n    this.aryC = [];\n    this.aryD = [];\n    this.aryH = [];\n    this.arySIG = [];\n    this.aryL = [];\n    this.aryU = [];\n    this.aryZ = [];\n  }\n  /*\n   * are we empty or not\n   */\n\n\n  hasKnots() {\n    return this.arySrcX.length > 0 ? true : false;\n  }\n  /*\n   * number of knots\n   */\n\n\n  get numKnots() {\n    return this.arySrcX.length;\n  }\n\n  get minX() {\n    if (null === this.arySrcX || this.arySrcX.length === 0) return null;\n    return this.arySrcX[0];\n  }\n\n  get maxX() {\n    if (null === this.arySrcX || this.arySrcX.length === 0) return null;\n    return this.arySrcX[this.arySrcX.length - 1];\n  }\n  /*\n   * is i a valid index into arySrcX or arySrcY ?\n   * - check valid integer, not real number\n   */\n\n\n  isValidKnotsIndex(i) {\n    var isInt = i % 1 === 0;\n    if (false === isInt) return false;\n    return this.arySrcX.length > i && i >= 0;\n  }\n  /*\n   * add 1 knot point\n   * return: true / false;\n   */\n\n\n  append(point) {\n    if (typeof point === \"undefined\" || null === point) return false;\n\n    if (!this.hasKnots() || point.x > this.arySrcX[this.arySrcX.length - 1]) {\n      this.arySrcX.push(point.x);\n      this.arySrcY.push(point.y);\n      return true;\n    } // else \n    // {\n    //     /*\n    //      * consider points prior to start \n    //      * and points after end\n    //      */\n    //     var index = this.bisection(point.x) + 1;\n    //     this.arySrcX.splice(index, 0, point.x);\n    //     this.arySrcY.splice(index, 0, point.y);\n    //     return true;\n    // }\n    // never reach here\n    //return false;\n\n  }\n  /*\n   * remove n knots \n   * - use append() for addition feature of splice\n   */\n\n\n  splice(index, // index of operation\n  removeCount) {\n    // number of knots to remove\n    if (false === this.isValidKnotsIndex(index) || // valid input ?\n    false === this.hasKnots()) // have content ?\n      return false;\n    if (removeCount < 0 || // valid input ?\n    false === this.isValidKnotsIndex(index + removeCount)) // valid index ?\n      return false;\n    this.arySrcX.splice(index, removeCount);\n    this.arySrcY.splice(index, removeCount);\n    return true;\n  }\n  /*\n   * replace population with sub-set\n   */\n\n\n  slice(start, end) {\n    if (start > end || // valid order\n    false === this.isValidKnotsIndex(end) && // valid end index\n    false === this.isValidKnotsIndex(start)) // valid start index\n      return false;\n    this.arySrcX = this.arySrcX.slice(start, end);\n    this.arySrcY = this.arySrcY.slice(start, end);\n    return true;\n  }\n\n  setKnotsFromArrays(arrayX, arrayY) {\n    if (typeof arrayX === \"undefined\" || null == arrayX) return false;\n    if (typeof arrayY === \"undefined\" || null == arrayY) return false;\n    if (arrayX.length !== arrayY.length || arrayX.length === 0) return false;\n    this.arySrcX = arrayX;\n    this.arySrcY = arrayY;\n    return true;\n  }\n  /*\n   * set all knots from points\n   */\n\n\n  setKnotsFromPoints(arrayOfPoints) {\n    if (typeof arrayOfPoints === \"undefined\" || null == arrayOfPoints) return false;\n    this.arySrcX = [];\n    this.arySrcY = [];\n\n    for (var i = 0; i < arrayOfPoints.length; i++) {\n      var p = arrayOfPoints[i];\n      this.arySrcX.push(p.x);\n      this.arySrcY.push(p.y);\n    }\n\n    return true;\n  }\n  /*\n   * return all knots\n   */\n\n\n  get knots() {\n    var arrayOfPoints = [];\n\n    for (var i = 0; i < this.numKnots; i++) {\n      arrayOfPoints.push(new Point(this.arySrcX[i], this.arySrcY[i]));\n    }\n\n    return arrayOfPoints;\n  }\n  /*\n   * remove all knots\n   */\n\n\n  clear() {\n    this.init();\n  }\n  /*\n   * create all intermediate values prior calculations\n   * \n   * RETURN: true / false\t\t\t\t\n   */\n\n\n  formulate() {\n    if (!this.hasKnots()) return false;\n    this.initIntermediate(); // Theorem 3.11\t\t[A].[x] = [b]\t\t\t\t\t[A] -> n x n Matrix\n    //\t\t\t\t\t\t\t\t\t\t\t\t\t[b] -> n x n Matrix\n    //\t\t\t\t\t\t\t\t\t\t\t\t\t[x] -> c[] 0..n\n    //\tSTEP 1\t\teq. 4 (pg. 134)\n\n    for (var aa = 0; aa < this.numKnots - 1; aa++) this.aryH[aa] = this.arySrcX[aa + 1] - this.arySrcX[aa]; // [A], Hj = Xj+1 - Xj\n    // STEP 2\n\n\n    for (aa = 1; aa < this.numKnots - 1; aa++) // 0 -> n-1\n    this.arySIG[aa] = 3.0 / this.aryH[aa] * (this.arySrcY[aa + 1] - this.arySrcY[aa]) - 3.0 / this.aryH[aa - 1] * (this.arySrcY[aa] - this.arySrcY[aa - 1]); // STEP 3\n\n\n    this.aryL[0] = 0;\n    this.aryU[0] = 0;\n    this.aryZ[0] = 0; // STEP 4\n\n    for (aa = 1; aa < this.numKnots - 1; aa++) {\n      this.aryL[aa] = 2.0 * (this.arySrcX[aa + 1] - this.arySrcX[aa - 1]) - this.aryH[aa - 1] * this.aryU[aa - 1];\n      this.aryU[aa] = this.aryH[aa] / this.aryL[aa];\n      this.aryZ[aa] = (this.arySIG[aa] - this.aryH[aa - 1] * this.aryZ[aa - 1]) / this.aryL[aa];\n    } // STEP 5\t\tTAIL BOUNDARY @ 0\n\n\n    this.aryL[this.numKnots - 1] = 1;\n    this.aryZ[this.numKnots - 1] = 0;\n    this.aryC[this.numKnots - 1] = 0; // STEP 6\n\n    for (aa = this.numKnots - 2; aa >= 0; aa--) {\n      this.aryC[aa] = this.aryZ[aa] - this.aryU[aa] * this.aryC[aa + 1]; // Theorem 3.11\n\n      this.aryB[aa] = (this.arySrcY[aa + 1] - this.arySrcY[aa]) / this.aryH[aa] - this.aryH[aa] * (this.aryC[aa + 1] + 2 * this.aryC[aa]) / 3; // eq. 10\n\n      this.aryD[aa] = (this.aryC[aa + 1] - this.aryC[aa]) / (3 * this.aryH[aa]); // eq. 11\n    }\n  }\n  /*\n   * Get the y-axis value from the cubic spline function\n   * RETURN: y (real-number) value for x-coordinate (real-value)\n   */\n\n\n  interpolateY(x) {\n    // input x (real-number)\n    var index = this.bisection(x);\n    if (this.arySrcX[index] === x) return this.arySrcY[index];else return this.doCubicSpline(x, index);\n  }\n  /*\n   * bisection search to locate x-axis values for input\n   * - intended as a private method\n   */\n\n\n  bisection(ab) {\n    // x-axis value\n    var ju = this.numKnots - 1; // upper limit\n\n    var jl = 0; // lower limit\n\n    var jm; // midpoint\n\n    while (ju - jl > 1) {\n      jm = Math.round((ju + jl) / 2); // midpoint formula\n\n      if (ab > this.arySrcX[jm]) jl = jm;else ju = jm;\n    }\n\n    return jl;\n  }\n  /*\n   * calculate the y value\n   * - intended to be a private method\n   * WARNING: must have invoked formulate() before this.\n   * RETURN: -1 if invalid, positive value if ok.\n   */\n\n\n  doCubicSpline(x, // [in] x value\n  index) {\n    // [in] index of anchor to use\n    var Y;\n    Y = this.arySrcY[index] + this.aryB[index] * (x - this.arySrcX[index]) + this.aryC[index] * Math.pow(x - this.arySrcX[index], 2) + this.aryD[index] * Math.pow(x - this.arySrcX[index], 3);\n    return Y;\n  }\n\n}\n\nexport default CubicSpline;","map":{"version":3,"sources":["/home/parvin/Documents/my-app/src/CubicSpline.js"],"names":["Point","CubicSpline","constructor","init","arySrcX","arySrcY","initIntermediate","aryB","aryC","aryD","aryH","arySIG","aryL","aryU","aryZ","hasKnots","length","numKnots","minX","maxX","isValidKnotsIndex","i","isInt","append","point","x","push","y","splice","index","removeCount","slice","start","end","setKnotsFromArrays","arrayX","arrayY","setKnotsFromPoints","arrayOfPoints","p","knots","clear","formulate","aa","interpolateY","bisection","doCubicSpline","ab","ju","jl","jm","Math","round","Y","pow"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAP,MAAkB,SAAlB;;AAEA,MAAMC,WAAN,CACA;AACIC,EAAAA,WAAW,GACX;AACI,SAAKC,IAAL;AACH;AAED;;;;;AAGAA,EAAAA,IAAI,GAAG;AACH,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,gBAAL;AACH;AAED;;;;;AAGAA,EAAAA,gBAAgB,GAChB;AACI,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,IAAL,GAAY,EAAZ;AACH;AAED;;;;;AAGAC,EAAAA,QAAQ,GACR;AACI,WAAQ,KAAKX,OAAL,CAAaY,MAAb,GAAoB,CAArB,GAAyB,IAAzB,GAA8B,KAArC;AACH;AAED;;;;;AAGA,MAAIC,QAAJ,GAAe;AACX,WAAO,KAAKb,OAAL,CAAaY,MAApB;AACH;;AAED,MAAIE,IAAJ,GAAW;AACP,QAAG,SAAO,KAAKd,OAAZ,IAAuB,KAAKA,OAAL,CAAaY,MAAb,KAAsB,CAAhD,EACI,OAAO,IAAP;AAEJ,WAAO,KAAKZ,OAAL,CAAa,CAAb,CAAP;AACH;;AAED,MAAIe,IAAJ,GAAW;AACP,QAAG,SAAO,KAAKf,OAAZ,IAAuB,KAAKA,OAAL,CAAaY,MAAb,KAAsB,CAAhD,EACA,OAAO,IAAP;AAEA,WAAO,KAAKZ,OAAL,CAAa,KAAKA,OAAL,CAAaY,MAAb,GAAoB,CAAjC,CAAP;AACH;AAED;;;;;;AAIAI,EAAAA,iBAAiB,CAACC,CAAD,EACjB;AACI,QAAIC,KAAK,GAAID,CAAC,GAAG,CAAJ,KAAU,CAAvB;AACA,QAAG,UAAUC,KAAb,EACI,OAAO,KAAP;AAEJ,WAAO,KAAKlB,OAAL,CAAaY,MAAb,GAAoBK,CAApB,IAAyBA,CAAC,IAAE,CAAnC;AACH;AAED;;;;;;AAIAE,EAAAA,MAAM,CAACC,KAAD,EAAQ;AAEV,QAAG,OAAOA,KAAP,KAAkB,WAAlB,IACA,SAAOA,KADV,EAEG,OAAO,KAAP;;AAEH,QAAG,CAAC,KAAKT,QAAL,EAAD,IACAS,KAAK,CAACC,CAAN,GAAU,KAAKrB,OAAL,CAAa,KAAKA,OAAL,CAAaY,MAAb,GAAoB,CAAjC,CADb,EAEA;AACI,WAAKZ,OAAL,CAAasB,IAAb,CAAkBF,KAAK,CAACC,CAAxB;AACA,WAAKpB,OAAL,CAAaqB,IAAb,CAAkBF,KAAK,CAACG,CAAxB;AACA,aAAO,IAAP;AACH,KAZS,CAaV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACH;AAED;;;;;;AAIAC,EAAAA,MAAM,CAACC,KAAD,EAAkB;AACjBC,EAAAA,WADD,EACc;AAAI;AAEpB,QAAG,UAAQ,KAAKV,iBAAL,CAAuBS,KAAvB,CAAR,IAAsD;AACtD,cAAQ,KAAKd,QAAL,EADX,EACyD;AACrD,aAAO,KAAP;AAEJ,QAAGe,WAAW,GAAG,CAAd,IAAqD;AACrD,cAAQ,KAAKV,iBAAL,CAAuBS,KAAK,GAACC,WAA7B,CADX,EACyD;AACrD,aAAO,KAAP;AAEJ,SAAK1B,OAAL,CAAawB,MAAb,CAAoBC,KAApB,EAA2BC,WAA3B;AACA,SAAKzB,OAAL,CAAauB,MAAb,CAAoBC,KAApB,EAA2BC,WAA3B;AACA,WAAO,IAAP;AACH;AAED;;;;;AAGAC,EAAAA,KAAK,CAACC,KAAD,EAAQC,GAAR,EAAa;AACd,QAAGD,KAAK,GAAGC,GAAR,IAA+C;AAC7C,cAAU,KAAKb,iBAAL,CAAuBa,GAAvB,CAAV,IAA6C;AAC9C,cAAU,KAAKb,iBAAL,CAAuBY,KAAvB,CAFd,EAEkD;AAC9C,aAAO,KAAP;AAEJ,SAAK5B,OAAL,GAAe,KAAKA,OAAL,CAAa2B,KAAb,CAAmBC,KAAnB,EAA0BC,GAA1B,CAAf;AACA,SAAK5B,OAAL,GAAe,KAAKA,OAAL,CAAa0B,KAAb,CAAmBC,KAAnB,EAA0BC,GAA1B,CAAf;AACA,WAAO,IAAP;AACH;;AAEJC,EAAAA,kBAAkB,CAACC,MAAD,EAASC,MAAT,EAClB;AACC,QAAG,OAAOD,MAAP,KAAmB,WAAnB,IACO,QAAMA,MADhB,EAEU,OAAO,KAAP;AAEV,QAAG,OAAOC,MAAP,KAAmB,WAAnB,IACO,QAAMA,MADhB,EAEU,OAAO,KAAP;AAEV,QAAGD,MAAM,CAACnB,MAAP,KAAkBoB,MAAM,CAACpB,MAAzB,IACAmB,MAAM,CAACnB,MAAP,KAAkB,CADrB,EAEC,OAAO,KAAP;AAEK,SAAKZ,OAAL,GAAe+B,MAAf;AACA,SAAK9B,OAAL,GAAe+B,MAAf;AACN,WAAO,IAAP;AACA;AAEE;;;;;AAGAC,EAAAA,kBAAkB,CAACC,aAAD,EAAgB;AAC9B,QAAG,OAAOA,aAAP,KAA0B,WAA1B,IACC,QAAMA,aADV,EAEI,OAAO,KAAP;AAEJ,SAAKlC,OAAL,GAAe,EAAf;AACA,SAAKC,OAAL,GAAe,EAAf;;AACA,SAAI,IAAIgB,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACiB,aAAa,CAACtB,MAA7B,EAAqCK,CAAC,EAAtC,EACA;AACL,UAAIkB,CAAC,GAAGD,aAAa,CAACjB,CAAD,CAArB;AACS,WAAKjB,OAAL,CAAasB,IAAb,CAAkBa,CAAC,CAACd,CAApB;AACT,WAAKpB,OAAL,CAAaqB,IAAb,CAAkBa,CAAC,CAACZ,CAApB;AACM;;AACP,WAAO,IAAP;AACG;AAED;;;;;AAGA,MAAIa,KAAJ,GAAY;AACR,QAAIF,aAAa,GAAG,EAApB;;AACA,SAAI,IAAIjB,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,KAAKJ,QAApB,EAA8BI,CAAC,EAA/B,EACA;AACIiB,MAAAA,aAAa,CAACZ,IAAd,CAAmB,IAAI1B,KAAJ,CAAU,KAAKI,OAAL,CAAaiB,CAAb,CAAV,EAA2B,KAAKhB,OAAL,CAAagB,CAAb,CAA3B,CAAnB;AACH;;AACD,WAAOiB,aAAP;AACH;AAED;;;;;AAGAG,EAAAA,KAAK,GAAG;AACJ,SAAKtC,IAAL;AACH;AAED;;;;;;;AAKAuC,EAAAA,SAAS,GAAG;AAER,QAAG,CAAC,KAAK3B,QAAL,EAAJ,EACI,OAAO,KAAP;AAEJ,SAAKT,gBAAL,GALQ,CAOR;AACA;AACA;AACA;;AACA,SAAK,IAAIqC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,KAAK1B,QAAL,GAAc,CAApC,EAAuC0B,EAAE,EAAzC,EACI,KAAKjC,IAAL,CAAUiC,EAAV,IAAgB,KAAKvC,OAAL,CAAauC,EAAE,GAAC,CAAhB,IAAqB,KAAKvC,OAAL,CAAauC,EAAb,CAArC,CAZI,CAYqD;AAE7D;;;AACA,SAAKA,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAG,KAAK1B,QAAL,GAAc,CAAhC,EAAmC0B,EAAE,EAArC,EAA4C;AACxC,SAAKhC,MAAL,CAAYgC,EAAZ,IAAmB,MAAI,KAAKjC,IAAL,CAAUiC,EAAV,CAAJ,IAAqB,KAAKtC,OAAL,CAAasC,EAAE,GAAC,CAAhB,IAAqB,KAAKtC,OAAL,CAAasC,EAAb,CAA1C,CAAD,GACG,MAAI,KAAKjC,IAAL,CAAUiC,EAAE,GAAC,CAAb,CAAJ,IAAuB,KAAKtC,OAAL,CAAasC,EAAb,IAAmB,KAAKtC,OAAL,CAAasC,EAAE,GAAC,CAAhB,CAA1C,CADrB,CAhBI,CAmBR;;;AACA,SAAK/B,IAAL,CAAU,CAAV,IAAe,CAAf;AACA,SAAKC,IAAL,CAAU,CAAV,IAAe,CAAf;AACA,SAAKC,IAAL,CAAU,CAAV,IAAe,CAAf,CAtBQ,CAwBR;;AACA,SAAK6B,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAG,KAAK1B,QAAL,GAAc,CAAhC,EAAmC0B,EAAE,EAArC,EACA;AACI,WAAK/B,IAAL,CAAU+B,EAAV,IAAiB,OAAO,KAAKvC,OAAL,CAAauC,EAAE,GAAC,CAAhB,IAAqB,KAAKvC,OAAL,CAAauC,EAAE,GAAC,CAAhB,CAA5B,CAAD,GAAqD,KAAKjC,IAAL,CAAUiC,EAAE,GAAC,CAAb,IAAkB,KAAK9B,IAAL,CAAU8B,EAAE,GAAC,CAAb,CAAvF;AACA,WAAK9B,IAAL,CAAU8B,EAAV,IAAgB,KAAKjC,IAAL,CAAUiC,EAAV,IAAgB,KAAK/B,IAAL,CAAU+B,EAAV,CAAhC;AACA,WAAK7B,IAAL,CAAU6B,EAAV,IAAgB,CAAC,KAAKhC,MAAL,CAAYgC,EAAZ,IAAmB,KAAKjC,IAAL,CAAUiC,EAAE,GAAC,CAAb,IAAkB,KAAK7B,IAAL,CAAU6B,EAAE,GAAC,CAAb,CAAtC,IAA0D,KAAK/B,IAAL,CAAU+B,EAAV,CAA1E;AACH,KA9BO,CAgCR;;;AACA,SAAK/B,IAAL,CAAU,KAAKK,QAAL,GAAc,CAAxB,IAA6B,CAA7B;AACA,SAAKH,IAAL,CAAU,KAAKG,QAAL,GAAc,CAAxB,IAA6B,CAA7B;AACA,SAAKT,IAAL,CAAU,KAAKS,QAAL,GAAc,CAAxB,IAA6B,CAA7B,CAnCQ,CAqCR;;AACA,SAAK0B,EAAE,GAAG,KAAK1B,QAAL,GAAc,CAAxB,EAA2B0B,EAAE,IAAI,CAAjC,EAAoCA,EAAE,EAAtC,EACA;AACI,WAAKnC,IAAL,CAAUmC,EAAV,IAAgB,KAAK7B,IAAL,CAAU6B,EAAV,IAAiB,KAAK9B,IAAL,CAAU8B,EAAV,IAAgB,KAAKnC,IAAL,CAAUmC,EAAE,GAAC,CAAb,CAAjD,CADJ,CAC2E;;AACvE,WAAKpC,IAAL,CAAUoC,EAAV,IAAgB,CAAC,KAAKtC,OAAL,CAAasC,EAAE,GAAC,CAAhB,IAAqB,KAAKtC,OAAL,CAAasC,EAAb,CAAtB,IAA0C,KAAKjC,IAAL,CAAUiC,EAAV,CAA1C,GACD,KAAKjC,IAAL,CAAUiC,EAAV,KAAiB,KAAKnC,IAAL,CAAUmC,EAAE,GAAC,CAAb,IAAkB,IAAI,KAAKnC,IAAL,CAAUmC,EAAV,CAAvC,IAAwD,CADvE,CAFJ,CAGgF;;AAC5E,WAAKlC,IAAL,CAAUkC,EAAV,IAAgB,CAAC,KAAKnC,IAAL,CAAUmC,EAAE,GAAC,CAAb,IAAkB,KAAKnC,IAAL,CAAUmC,EAAV,CAAnB,KAAqC,IAAI,KAAKjC,IAAL,CAAUiC,EAAV,CAAzC,CAAhB,CAJJ,CAI+E;AAC9E;AACJ;AAED;;;;;;AAIAC,EAAAA,YAAY,CAACnB,CAAD,EAAI;AAAoB;AAChC,QAAII,KAAK,GAAG,KAAKgB,SAAL,CAAepB,CAAf,CAAZ;AAEA,QAAG,KAAKrB,OAAL,CAAayB,KAAb,MAAwBJ,CAA3B,EACI,OAAO,KAAKpB,OAAL,CAAawB,KAAb,CAAP,CADJ,KAGI,OAAO,KAAKiB,aAAL,CAAmBrB,CAAnB,EAAsBI,KAAtB,CAAP;AACP;AAED;;;;;;AAIAgB,EAAAA,SAAS,CAACE,EAAD,EAAK;AAA8D;AACxE,QAAIC,EAAE,GAAG,KAAK/B,QAAL,GAAc,CAAvB,CADU,CAC8B;;AACxC,QAAIgC,EAAE,GAAG,CAAT,CAFU,CAEoB;;AAC9B,QAAIC,EAAJ,CAHU,CAGiB;;AAE3B,WAAOF,EAAE,GAAGC,EAAL,GAAU,CAAjB,EACA;AACIC,MAAAA,EAAE,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,EAAE,GAAGC,EAAN,IAAU,CAArB,CAAL,CADJ,CAC0C;;AAEtC,UAAIF,EAAE,GAAG,KAAK3C,OAAL,CAAa8C,EAAb,CAAT,EACID,EAAE,GAAGC,EAAL,CADJ,KAGIF,EAAE,GAAGE,EAAL;AACP;;AACD,WAAOD,EAAP;AACH;AAED;;;;;;;;AAMAH,EAAAA,aAAa,CAACrB,CAAD,EAAQ;AACPI,EAAAA,KADD,EACQ;AAAI;AACrB,QAAIwB,CAAJ;AAEAA,IAAAA,CAAC,GAAG,KAAKhD,OAAL,CAAawB,KAAb,IACJ,KAAKtB,IAAL,CAAUsB,KAAV,KAAoBJ,CAAC,GAAG,KAAKrB,OAAL,CAAayB,KAAb,CAAxB,CADI,GAEJ,KAAKrB,IAAL,CAAUqB,KAAV,IAAmBsB,IAAI,CAACG,GAAL,CAAU7B,CAAC,GAAG,KAAKrB,OAAL,CAAayB,KAAb,CAAd,EAAoC,CAApC,CAFf,GAGJ,KAAKpB,IAAL,CAAUoB,KAAV,IAAmBsB,IAAI,CAACG,GAAL,CAAU7B,CAAC,GAAG,KAAKrB,OAAL,CAAayB,KAAb,CAAd,EAAoC,CAApC,CAHnB;AAIA,WAAOwB,CAAP;AACH;;AAxSL;;AA2SA,eAAepD,WAAf","sourcesContent":["// ============================================================================\n// Module:\t\tCubicSpline.js\n//\n// Description:\t2D Cubic Spline interpolation in javascript as defined by reference.\n//\t\t\t\t\n// Reference:\tNumerical Recipes in C 2nd Edition, Press, Teukolsky, Vetterling, Flannery, pg.113\n//\t\t\t\n// Authors:\t\tWilliam H. Press\n//\t\t\t\tWilliam T. Vetterling\n//\t\t\t\tSaul A. Teukolsky\n//\t\t\t\tBrian P. Flannery\n//\n//\t\t\t\tC.T. Yeung (porting from C into javascript)\n//\n// Input:\t\tpSrcX - array of anchors' x (assume positive real numbers)\n//\t\t\t\tpSrcY - array of anchors' y (assume positive real numbers)\n//\n// Output:\t\tgetY(x) => returns interpolated Y value.\n//\n// WARNING:     must invoke formulate() after all knots are added before getY(x)\n//\n// History:\t\n// 20Nov11\t\tported it to javascript, working in HTML5 canvas.\t\t\tcty\n// 12Nov17      upgrade to ECMAScript6                                      cty\n// ============================================================================\nimport Point from './Point';\n\nclass CubicSpline\n{\n    constructor()\n    {\n        this.init();\n    }\n\n    /*\n     * instantiate all arrays (knots + intermediate)\n     */\n    init() {\n        this.arySrcX = [];\n        this.arySrcY = [];\n        this.initIntermediate();\n    }\n\n    /*\n     * instantiate intermediate arrays\n     */\n    initIntermediate()\n    {\n        this.aryB = [];\n        this.aryC = [];\n        this.aryD = [];\n        this.aryH = [];\n        this.arySIG = [];\n        this.aryL = [];\n        this.aryU = [];\n        this.aryZ = [];\n    }\n\n    /*\n     * are we empty or not\n     */\n    hasKnots()\n    {\n        return (this.arySrcX.length>0)? true:false;\n    }\n\n    /*\n     * number of knots\n     */\n    get numKnots() {\n        return this.arySrcX.length;\n    }\n\n    get minX() {\n        if(null===this.arySrcX || this.arySrcX.length===0)\n            return null;\n\n        return this.arySrcX[0];\n    }\n\n    get maxX() {\n        if(null===this.arySrcX || this.arySrcX.length===0)\n        return null;\n\n        return this.arySrcX[this.arySrcX.length-1];\n    }\n\n    /*\n     * is i a valid index into arySrcX or arySrcY ?\n     * - check valid integer, not real number\n     */\n    isValidKnotsIndex(i)\n    {\n        var isInt = (i % 1 === 0);\n        if(false === isInt)\n            return false;\n\n        return this.arySrcX.length>i && i>=0;\n    }\n\n    /*\n     * add 1 knot point\n     * return: true / false;\n     */\n    append(point) {\n        \n        if(typeof(point) === \"undefined\" ||\n           null===point)\n           return false;\n\n        if(!this.hasKnots() ||\n           point.x > this.arySrcX[this.arySrcX.length-1])\n        {\n            this.arySrcX.push(point.x);\n            this.arySrcY.push(point.y);\n            return true;\n        }\n        // else \n        // {\n        //     /*\n        //      * consider points prior to start \n        //      * and points after end\n        //      */\n        //     var index = this.bisection(point.x) + 1;\n        //     this.arySrcX.splice(index, 0, point.x);\n        //     this.arySrcY.splice(index, 0, point.y);\n        //     return true;\n        // }\n        // never reach here\n        //return false;\n    }\n\n    /*\n     * remove n knots \n     * - use append() for addition feature of splice\n     */\n    splice(index,           // index of operation\n           removeCount) {   // number of knots to remove\n\n        if(false===this.isValidKnotsIndex(index) ||              // valid input ?\n           false===this.hasKnots())                              // have content ?\n            return false;\n\n        if(removeCount < 0 ||                                   // valid input ?\n           false===this.isValidKnotsIndex(index+removeCount) )   // valid index ?\n            return false;\n\n        this.arySrcX.splice(index, removeCount);\n        this.arySrcY.splice(index, removeCount);\n        return true;\n    }\n\n    /*\n     * replace population with sub-set\n     */\n    slice(start, end) {\n        if(start > end ||                                 // valid order\n            (false === this.isValidKnotsIndex(end) &&     // valid end index\n            false === this.isValidKnotsIndex(start)))     // valid start index\n            return false;\n\n        this.arySrcX = this.arySrcX.slice(start, end);    \n        this.arySrcY = this.arySrcY.slice(start, end);    \n        return true;\n    }\n\t\n\tsetKnotsFromArrays(arrayX, arrayY)\n\t{\n\t\tif(typeof(arrayX) === \"undefined\" ||\n            null==arrayX)\n            return false;\n\n\t\tif(typeof(arrayY) === \"undefined\" ||\n            null==arrayY)\n            return false;\n\t\t\n\t\tif(arrayX.length !== arrayY.length ||\n\t\t   arrayX.length === 0)\n\t\t\treturn false;\n\t\t\n        this.arySrcX = arrayX;\n        this.arySrcY = arrayY;\n\t\treturn true;\n\t}\n\n    /*\n     * set all knots from points\n     */\n    setKnotsFromPoints(arrayOfPoints) {\n        if(typeof(arrayOfPoints) === \"undefined\" ||\n            null==arrayOfPoints)\n            return false;\n\n        this.arySrcX = [];\n        this.arySrcY = [];\n        for(var i=0; i<arrayOfPoints.length; i++)\n        {\n\t\t\tvar p = arrayOfPoints[i];\n            this.arySrcX.push(p.x);\n\t\t\tthis.arySrcY.push(p.y);\n        }\n\t\treturn true;\n    }\n\n    /*\n     * return all knots\n     */\n    get knots() {\n        var arrayOfPoints = [];\n        for(var i=0; i<this.numKnots; i++)\n        {\n            arrayOfPoints.push(new Point(this.arySrcX[i], this.arySrcY[i]));\n        }\n        return arrayOfPoints;\n    }\n\n    /*\n     * remove all knots\n     */\n    clear() {\n        this.init();\n    }\n                        \n    /*\n     * create all intermediate values prior calculations\n     * \n     * RETURN: true / false\t\t\t\t\n     */\n    formulate() { \t\t\t\t\t\t\t\n\n        if(!this.hasKnots())\n            return false;\n        \n        this.initIntermediate();\n        \n        // Theorem 3.11\t\t[A].[x] = [b]\t\t\t\t\t[A] -> n x n Matrix\n        //\t\t\t\t\t\t\t\t\t\t\t\t\t[b] -> n x n Matrix\n        //\t\t\t\t\t\t\t\t\t\t\t\t\t[x] -> c[] 0..n\n        //\tSTEP 1\t\teq. 4 (pg. 134)\n        for (var aa = 0; aa < this.numKnots-1; aa ++)\n            this.aryH[aa] = this.arySrcX[aa+1] - this.arySrcX[aa];\t\t\t// [A], Hj = Xj+1 - Xj\n\n        // STEP 2\n        for (aa = 1; aa < this.numKnots-1; aa ++)\t\t\t// 0 -> n-1\n            this.arySIG[aa] = (3.0/this.aryH[aa] * (this.arySrcY[aa+1] - this.arySrcY[aa])) - \n                                (3.0/this.aryH[aa-1] * (this.arySrcY[aa] - this.arySrcY[aa-1]));\n        \n        // STEP 3\n        this.aryL[0] = 0;\n        this.aryU[0] = 0;\n        this.aryZ[0] = 0;\n\n        // STEP 4\n        for (aa = 1; aa < this.numKnots-1; aa ++)\n        {\n            this.aryL[aa] = (2.0 * (this.arySrcX[aa+1] - this.arySrcX[aa-1])) - (this.aryH[aa-1] * this.aryU[aa-1]);\n            this.aryU[aa] = this.aryH[aa] / this.aryL[aa];\n            this.aryZ[aa] = (this.arySIG[aa] - (this.aryH[aa-1] * this.aryZ[aa-1])) / this.aryL[aa];\n        }\n        \n        // STEP 5\t\tTAIL BOUNDARY @ 0\n        this.aryL[this.numKnots-1] = 1;\n        this.aryZ[this.numKnots-1] = 0;\n        this.aryC[this.numKnots-1] = 0;\n        \n        // STEP 6\n        for (aa = this.numKnots-2; aa >= 0; aa --)\n        {\n            this.aryC[aa] = this.aryZ[aa] - (this.aryU[aa] * this.aryC[aa+1]);\t\t\t\t\t// Theorem 3.11\n            this.aryB[aa] = (this.arySrcY[aa+1] - this.arySrcY[aa]) / this.aryH[aa] \n                        - (this.aryH[aa] * (this.aryC[aa+1] + 2 * this.aryC[aa]) / 3);\t\t// eq. 10\n            this.aryD[aa] = (this.aryC[aa+1] - this.aryC[aa]) / (3 * this.aryH[aa]);\t\t\t// eq. 11\n        }\n    }\n\n    /*\n     * Get the y-axis value from the cubic spline function\n     * RETURN: y (real-number) value for x-coordinate (real-value)\n     */\n    interpolateY(x) {                   // input x (real-number)\n        var index = this.bisection(x);\n        \n        if(this.arySrcX[index] === x)\n            return this.arySrcY[index];\n        else\n            return this.doCubicSpline(x, index);\n    }\n\n    /*\n     * bisection search to locate x-axis values for input\n     * - intended as a private method\n     */\n    bisection(ab) {                                                             // x-axis value\n        var ju = this.numKnots-1;\t\t\t\t\t\t\t\t\t\t\t    // upper limit\n        var jl = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // lower limit\n        var jm;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // midpoint\n\n        while (ju - jl > 1)\t\t\t\t\t\t\t\n        {\n            jm = Math.round((ju + jl)/2);\t\t\t\t\t\t\t\t\t// midpoint formula\n\n            if (ab > this.arySrcX[jm])\n                jl = jm;\n            else\n                ju = jm;\n        }\n        return jl;\t\t\n    }\n\n    /*\n     * calculate the y value\n     * - intended to be a private method\n     * WARNING: must have invoked formulate() before this.\n     * RETURN: -1 if invalid, positive value if ok.\n     */\n    doCubicSpline(x, \t\t\t\t// [in] x value\n                  index) {\t\t\t// [in] index of anchor to use\n        var Y;\n        \n        Y = this.arySrcY[index]\t\t\t\t\t\t\t\t\t    + \n        this.aryB[index] *\t(x - this.arySrcX[index])\t\t\t\t+\n        this.aryC[index] *\tMath.pow((x - this.arySrcX[index]), 2) \t+\n        this.aryD[index] * Math.pow((x - this.arySrcX[index]), 3);\n        return Y;\n    }\n}\n\nexport default CubicSpline;"]},"metadata":{},"sourceType":"module"}